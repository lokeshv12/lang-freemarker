'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var lr = require('@lezer/lr');
var highlight = require('@lezer/highlight');
var view = require('@codemirror/view');
var state = require('@codemirror/state');
var language = require('@codemirror/language');
var autocomplete = require('@codemirror/autocomplete');

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,true:30, false:30};
const parser = lr.LRParser.deserialize({
  version: 14,
  states: "'nQYQPOOPhOPOOOmOPO'#C`OrQQO'#C_O!QQQO'#C_O!`QQO'#DVOOQO'#C}'#C}OOQO'#Cr'#CrQYQPOOP!nO`O'#C]POOO)C>m)C>mO!yOSO,58zO#RQWO'#CgOOQO'#DO'#DOOOQO'#Ct'#CtOrQQO,58yO#jOPO'#ClOOQO,58y,58yO#oQQO,58yOOQO'#Cj'#CjOOQO'#DT'#DTO#}QPO,59qOOQO-E6p-E6pPOOO'#Cq'#CqP$SO`O,58wPOOO,58w,58wOOOO'#Cs'#CsO$_OSO1G.fOOQO1G.f1G.fO$gQWO'#CuO%OQSO'#DRO%OQSO'#DRO!`QQO'#DRO%WQSO,59ROOQO-E6r-E6rOOQO1G.e1G.eO%]OSO,59WOOQO1G/]1G/]POOO-E6o-E6oPOOO1G.c1G.cOOOO-E6q-E6qOOQO7+$Q7+$QOOQO,59a,59aO!`QQO,59aOOQO-E6s-E6sO%bQSO,59mO%bQSO,59mOOQO1G.m1G.mOOQO1G.r1G.rOOQO1G.{1G.{O%jQSO1G/X",
  stateData: "%y~OlOSmPQ~OTQObSOdUOzTO~OmXO~OUZO~OX]OY]Oa`Ot[O~OX]OY]OcaOt[O~OXcO[dO]dO_dO~OngOogOpiO~OVjOWlO~OXcO[dO]dO_dOvpOxmOsuP~OUtO~OX]OY]OcsOt[O~O{uO~OngOogOpwO~OVjOWyO~OXcO[dO]dO_dOv{OsiXxiX~OxmOsuX~Os!PO~OW!QO~OxmOsua~OxmOsui~OlUdYXd~",
  goto: "$TzP{P!O!SPPPPPP!WPP!^P!ePPPP!k!q!w!}#XPPPPPPP#g#kPP#qP#tP!ORYPTUOWTROWX]RS_bZdT[mp{QaRRs_QhXRvhQWORfWQkZRxkQ_RQbSTr_bQn[U|n}!SQ}oR!S!OTVOWX^RS_bRq[QeTQo[QzmQ!OpR!R{",
  nodeNames: "âš  Comment Template Variable OpenTag StartTag TagName AttributeName EndTag Identifier ChainedIdentifier ArrayExpression Number String VariableName BooleanLiteral CloseTag StartCloseTag OpenBrace CloseBrace PlainText",
  maxTerm: 43,
  nodeProps: [
    ["group", -6,3,12,13,14,15,20,"Entity",-3,9,10,11,"Expression"],
    ["closedBy", 4,"CloseTag",5,"StartCloseTag",18,"CloseBrace",19,"OpenBrace"],
    ["openedBy", -2,8,17,"StartTag",16,"OpenTag"]
  ],
  skippedNodes: [0,1,21],
  repeatNodeCount: 5,
  tokenData: "!)i~RyOX#rXY%hYZ%hZ]#r]^%h^p#rpq%hqr#rrs&zst.wtu0Uuw#rwx3[z|#r|}:V}!O#r!O!P;S!P!QB|!Q!RCZ!R![EV![!^#r!^!_! Z!_!`#r!`!a! |!a!b#r!b!c.w!c!}!!{!}#O!'Z#O#P#r#P#Q!'e#Q#R#r#R#S!!{#S#T#r#T#o!!{#o#p!(d#p#q#r#q#r!)[#r$g#r$g;'S!!{;'S;=`!'T<%lO!!{Q#w[dQOs#rux#rz!P#r!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rQ$pXOq#rrv#rw#Q#r#R#o#r#p;'S#r;'S;=`%]<%l~#r~O#r~~%cQ%`P;=`<%l#rQ%hOdQ~%ocl~dQOX#rXY%hYZ%hZ]#r]^%h^p#rpq%hqs#rux#rz!P#r!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rf'Rg]ddQOY&zYZ#rZr&zrs(jsu)gux&zxz)gz!P&z!P!Q)g!Q!^&z!^!_)g!_!b&z!b!c)g!c!}&z!}#O)g#O#P+_#P#o&z#o#p,r#p#q&z#q#r)g#r;'S&z;'S;=`.P<%lO&zf(q[]ddQOs#rux#rz!P#r!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rd)lW]dOY)gZr)grs*Us#O)g#O#P*Z#P;'S)g;'S;=`+X<%lO)gd*ZO]dd*^RO;'S)g;'S;=`*g;=`O)gd*lX]dOY)gZr)grs*Us#O)g#O#P*Z#P;'S)g;'S;=`+X;=`<%l)g<%lO)gd+[P;=`<%l)gf+dddQOs&zsu)gux&zxz)gz!P&z!P!Q)g!Q!^&z!^!_)g!_!b&z!b!c)g!c!}&z!}#O)g#O#o&z#o#p,r#p#q&z#q#r)g#r;'S&z;'S;=`.V;=`<%l)g<%lO&zf,wb]dOY&zYZ#rZq&zqr)grs(jsv&zvw)gw#O&z#O#P+_#P#Q&z#Q#R)g#R#o&z#o#p)g#p;'S&z;'S;=`.P<%l~&z~O&z~~%cf.SP;=`<%l&zf.[X]dOY)gZr)grs*Us#O)g#O#P*Z#P;'S)g;'S;=`+X;=`<%l&z<%lO)g~.zVtu/a!c!}/a#R#S/a#T#o/a$g;'S/a;'S;=`0O<%lO/a~/fWU~tu/a!Q![/a!c!}/a#R#S/a#T#o/a$g;'S/a;'S;=`0O<%lO/a~0RP;=`<%l/an0]YVWXdtu0{!O!P1o!Q![0{!c!}0{#R#S0{#T#o0{#o#p3V$g;'S0{;'S;=`3P<%lO0{l1SXVWXdtu0{!O!P1o!Q![0{!c!}0{#R#S0{#T#o0{$g;'S0{;'S;=`3P<%lO0{S1rVtu2X!c!}2X#R#S2X#T#o2X$g;'S2X;'S;=`2y<%lO2XS2^XYStu2X!O!P1o!Q![2X!c!}2X#R#S2X#T#o2X$g;'S2X;'S;=`2y<%lO2XS2|P;=`<%l2Xl3SP;=`<%l0{Q3[OzQf3cg]ddQOY3[YZ#rZs3[su4zuw3[wx(jxz4zz!P3[!P!Q4z!Q!^3[!^!_4z!_!b3[!b!c4z!c!}3[!}#O4z#O#P6m#P#o3[#o#p8Q#p#q3[#q#r4z#r;'S3[;'S;=`9_<%lO3[d5PW]dOY4zZw4zwx*Ux#O4z#O#P5i#P;'S4z;'S;=`6g<%lO4zd5lRO;'S4z;'S;=`5u;=`O4zd5zX]dOY4zZw4zwx*Ux#O4z#O#P5i#P;'S4z;'S;=`6g;=`<%l4z<%lO4zd6jP;=`<%l4zf6rddQOs3[su4zux3[xz4zz!P3[!P!Q4z!Q!^3[!^!_4z!_!b3[!b!c4z!c!}3[!}#O4z#O#o3[#o#p8Q#p#q3[#q#r4z#r;'S3[;'S;=`9e;=`<%l4z<%lO3[f8Vb]dOY3[YZ#rZq3[qr4zrv3[vw4zwx(jx#O3[#O#P6m#P#Q3[#Q#R4z#R#o3[#o#p4z#p;'S3[;'S;=`9_<%l~3[~O3[~~%cf9bP;=`<%l3[f9jX]dOY4zZw4zwx*Ux#O4z#O#P5i#P;'S4z;'S;=`6g;=`<%l3[<%lO4zj:^[xhdQOs#rux#rz!P#r!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rf;X^dQOs#rux#rz!O#r!O!P<T!Q![>O![!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rb<Y]dQOs#rux#rz!O#r!O!P=R!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rb=Y[v`dQOs#rux#rz!P#r!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rf>Vc[ddQOs#rux#rz!P#r!Q![>O![!^#r!_!b#r!c!g#r!g!h?b!h!}#r#O#R#r#R#S>O#S#X#r#X#Y?b#Y#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rf?gcdQOs#rux#rz{#r{|@r|}#r}!O@r!O!P#r!Q![Av![!^#r!_!b#r!c!}#r#O#R#r#R#SAv#S#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rf@w_dQOs#rux#rz!P#r!Q![Av![!^#r!_!b#r!c!}#r#O#R#r#R#SAv#S#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfA}_[ddQOs#rux#rz!P#r!Q![Av![!^#r!_!b#r!c!}#r#O#R#r#R#SAv#S#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#r[CPP!`!aCS[CZOWWaSfCbk[ddQOs#rux#rz!O#r!O!P>O!Q![EV![!^#r!_!b#r!c!g#r!g!h?b!h!}#r#O#R#r#R#SEV#S#U#r#U#VGo#V#X#r#X#Y?b#Y#b#r#b#cFr#c#dJV#d#l#r#l#mLg#m#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfE^f[ddQOs#rux#rz!O#r!O!P>O!Q![EV![!^#r!_!b#r!c!g#r!g!h?b!h!}#r#O#R#r#R#SEV#S#X#r#X#Y?b#Y#b#r#b#cFr#c#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfFy[[ddQOs#rux#rz!P#r!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfGt`dQOs#rux#rz!P#r!Q!RHv!R!SHv!S!^#r!_!b#r!c!}#r#O#R#r#R#SHv#S#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfH}b[ddQOs#rux#rz!P#r!Q!RHv!R!SHv!S!^#r!_!b#r!c!}#r#O#R#r#R#SHv#S#b#r#b#cFr#c#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfJ[_dQOs#rux#rz!P#r!Q!YKZ!Y!^#r!_!b#r!c!}#r#O#R#r#R#SKZ#S#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfKba[ddQOs#rux#rz!P#r!Q!YKZ!Y!^#r!_!b#r!c!}#r#O#R#r#R#SKZ#S#b#r#b#cFr#c#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfLlbdQOs#rux#rz!P#r!Q![Mt![!^#r!_!b#r!c!iMt!i!}#r#O#R#r#R#SMt#S#T#r#T#ZMt#Z#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rfM{d[ddQOs#rux#rz!P#r!Q![Mt![!^#r!_!b#r!c!iMt!i!}#r#O#R#r#R#SMt#S#T#r#T#ZMt#Z#b#r#b#cFr#c#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#r~! `QTQst! f!P!Q! w~! iP}!O! l~! oP}!O! r~! wOm~Q! |OTQ^!!V[WWaSdQOs#rux#rz!P#r!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#rn!#UcVWdQXdOs#rtu0{ux#rz!O#r!O!P!$a!Q![!!{![!^#r!_!b#r!c!}!!{#O#R#r#R#S!!{#S#T#r#T#o!!{#o#p$m#p#q#r#r$g#r$g;'S!!{;'S;=`!'T<%lO!!{U!$fadQOs#rtu2Xux#rz!P#r!Q!^#r!_!b#r!c!}!%k#O#R#r#R#S!%k#S#T#r#T#o!%k#o#p$m#p#q#r#r$g#r$g;'S!%k;'S;=`!&}<%lO!%kU!%rcdQYSOs#rtu2Xux#rz!O#r!O!P!$a!Q![!%k![!^#r!_!b#r!c!}!%k#O#R#r#R#S!%k#S#T#r#T#o!%k#o#p$m#p#q#r#r$g#r$g;'S!%k;'S;=`!&}<%lO!%kU!'QP;=`<%l!%kn!'WP;=`<%l!!{U!'bPtSTQ!P!Q! wn!'n[shaSdQOs#rux#rz!P#r!Q!^#r!_!b#r!c!}#r#O#o#r#o#p$m#p#q#r#r;'S#r;'S;=`%]<%lO#r~!(gYOq#rrv#rw#Q#r#R#o#r#o#p!)V#p;'S#r;'S;=`%]<%l~#r~O#r~~%c~!)[Ob~U!)aP{Q#q#r!)dS!)iOcS",
  tokenizers: [1, 2, 3, 4, new lr.LocalTokenGroup("p~RQYZX}!O^~^Oo~~aP}!Od~gP!`!aj~oOp~~", 31, 30)],
  topRules: {"Template":[0,2]},
  dialects: {noMatch: 0},
  specialized: [{term: 9, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 218
});

const Bool = ["true", "false"];
const GlobalAttrs = {
    accesskey: null,
    class: null,
    contenteditable: Bool,
};
const S = {}; // Empty tag spec
const Tags = {
    a: S,
};
class Schema {
    constructor(extraTags, extraAttrs) {
        this.tags = Object.assign(Object.assign({}, Tags), extraTags);
        this.globalAttrs = Object.assign(Object.assign({}, GlobalAttrs), extraAttrs);
        this.allTags = Object.keys(this.tags);
        this.globalAttrNames = Object.keys(this.globalAttrs);
    }
}
Schema.default = new Schema();
function elementName(doc, tree, max = doc.length) {
    if (!tree)
        return "";
    let tag = tree.firstChild;
    let name = tag && tag.getChild("TagName");
    return name ? String(doc).slice(name.from, Math.min(name.to, max)) : "";
}

const selfClosers = new Set("area base br col command embed frame hr img input keygen link meta param source track wbr menuitem".split(" "));
const specialVariables = [
    "auto_esc",
    "caller_template_name",
    "current_template_name",
    "data_model",
    "error",
    "get_optional_template",
    "globals",
    "lang",
    "locale",
    "locale_object",
    "locals",
    "main",
    "main_template_name",
    "namespace",
    "node",
    "now",
    "output_encoding ",
    "output_format",
    "template_name",
    "time_zone",
    "url_escaping_charset",
    "vars",
    "version",
];
const keyFunctions = [
    "assign",
    "attempt",
    "autoesc",
    "break",
    "case",
    "compress",
    "default",
    "else",
    "elseif",
    "escape",
    "fallback",
    "function",
    "flush",
    "ftl",
    "global",
    "if",
    "import",
    "include",
    "items",
    "list",
    "local",
    "lt",
    "macro",
    "nested",
    "noautoesc",
    "noescape",
    "noparse",
    "nt",
    "outputformat",
    "recover",
    "recurse",
    "return",
    "rt",
    "sep",
    "setting",
    "stop",
    "switch",
    "t",
    "visit",
];
const syntax_colors = language.syntaxHighlighting(language.HighlightStyle.define([
    { tag: highlight.tags.attributeName, color: "red" },
    { tag: highlight.tags.keyword, color: "#ffffff" },
]));
const FREEMARKERLanguage = language.LRLanguage.define({
    parser: parser.configure({
        props: [
            // indentNodeProp.add({
            //   Element(context) {
            //     let after = /^(\s*)(<\/)?/.exec(context.textAfter)!;
            //     if (context.node.to <= context.pos + after[0].length)
            //       return context.continue();
            //     return (
            //       context.lineIndent(context.node.from) +
            //       (after[2] ? 0 : context.unit)
            //     );
            //   },
            //   "OpenTag CloseTag SelfClosingTag"(context) {
            //     return context.column(context.node.from) + context.unit;
            //   },
            //   Document(context) {
            //     if (
            //       context.pos + /\s*/.exec(context.textAfter)![0].length <
            //       context.node.to
            //     )
            //       return context.continue();
            //     let endElt = null,
            //       close;
            //     for (let cur = context.node; ; ) {
            //       let last = cur.lastChild;
            //       if (!last || last.name != "Element" || last.to != cur.to) break;
            //       endElt = cur = last;
            //     }
            //     if (
            //       endElt &&
            //       !(
            //         (close = endElt.lastChild) &&
            //         (close.name == "CloseTag" || close.name == "SelfClosingTag")
            //       )
            //     )
            //       return context.lineIndent(endElt.from) + context.unit;
            //     return null;
            //   },
            // }),
            language.bracketMatchingHandle.add({
                "OpenTag CloseTag EndTag": (node) => node.getChild("TagName"),
            }),
            highlight.styleTags({
                Identifier: highlight.tags.atom,
                Comment: highlight.tags.blockComment,
                AttributeName: highlight.tags.attributeName,
                TagName: highlight.tags.tagName,
                "OpenTag CloseTag EndTag": highlight.tags.angleBracket,
                "OpenBrace CloseBrace": highlight.tags.brace,
                Variable: highlight.tags.variableName,
                Number: highlight.tags.number,
                String: highlight.tags.string,
                boolean: highlight.tags.bool
            }),
        ],
    }),
    languageData: {
        commentTokens: {
            block: {
                open: "<#--",
                close: "-->",
            },
        },
    },
});
function getAutoCompleteList() {
    return [...keyFunctions, ...specialVariables].map((key) => {
        let keyType = {
            label: key,
            type: "keyword",
        };
        return keyType;
    });
}
//Autocompletion
const FREEMARKERCompletion = FREEMARKERLanguage.data.of({
    autocomplete: autocomplete.completeFromList(getAutoCompleteList()),
});
const autoCloseTags = view.EditorView.inputHandler.of((view, from, to, text) => {
    if (view.composing ||
        view.state.readOnly ||
        from != to ||
        (text != ">" && text != "/") ||
        !FREEMARKERLanguage.isActiveAt(view.state, from, -1)) {
        return false;
    }
    let { state: state$1 } = view;
    let changes = state$1.changeByRange((range) => {
        var _a, _b, _c;
        let { head } = range, around = language.syntaxTree(state$1).resolveInner(head, -1), name;
        if (around.name == "TagName" || around.name == "StartTag")
            around = around.parent;
        if (text == ">" && around.name == "OpenTag") {
            if (((_b = (_a = around.parent) === null || _a === void 0 ? void 0 : _a.lastChild) === null || _b === void 0 ? void 0 : _b.name) != "CloseTag" &&
                (name = elementName(state$1.doc, around.parent, head)) &&
                !selfClosers.has(name)) {
                let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
                let insert = `${hasRightBracket ? "" : ">"}</${name}>`;
                return {
                    range: state.EditorSelection.cursor(head + 1),
                    changes: { from: head + (hasRightBracket ? 1 : 0), insert },
                };
            }
        }
        else if (text == "/" && around.name == "OpenTag") {
            let empty = around.parent, base = empty === null || empty === void 0 ? void 0 : empty.parent;
            if (empty.from == head - 1 &&
                ((_c = base.lastChild) === null || _c === void 0 ? void 0 : _c.name) != "CloseTag" &&
                (name = elementName(state$1.doc, base, head)) &&
                !selfClosers.has(name)) {
                let hasRightBracket = view.state.doc.sliceString(head, head + 1) === ">";
                let insert = `/${name}${hasRightBracket ? "" : ">"}`;
                let pos = head + insert.length + (hasRightBracket ? 1 : 0);
                return {
                    range: state.EditorSelection.cursor(pos),
                    changes: { from: head, insert },
                };
            }
        }
        return { range };
    });
    if (changes.changes.empty)
        return false;
    view.dispatch(changes, { userEvent: "input.type", scrollIntoView: true });
    return true;
});
function FREEMARKER(config = {}) {
    // FREEMARKERLanguage.data.of({
    //   autocomplete: htmlCompletionSourceWith(config),
    // });
    return new language.LanguageSupport(FREEMARKERLanguage, [FREEMARKERCompletion, autoCloseTags]);
}

exports.FREEMARKER = FREEMARKER;
exports.FREEMARKERCompletion = FREEMARKERCompletion;
exports.FREEMARKERLanguage = FREEMARKERLanguage;
exports.autoCloseTags = autoCloseTags;
exports.syntax_colors = syntax_colors;
